## closures
Ability of a function to remember its lexical parent scope and to have read/write access to its lexical parent scope objects.
```js
let myName = 'Peter';
function f1() {
    let newName = myName + '!'
    return function f2() {
        console.log("Hello,", myName);
        console.log("Hello,", newName);
    };
}

let res = f1();
res()
// Hello, Peter
// Hello, Peter!
```

##### Use of closures:
- Event Handling
- Callbacks

### memoize 
aka caching i.e. saving results from expensive computation to reproduce succeeding results quicker

```js
function memoize(func) {
    const cache = new Map();
    return function(...args){
        key = args.toString();
        if (cache.has(key)) {
            return cache.get(key);
        }
        result = func(...args);
        cache.set(result);
        return result
    }
}
```

lets take example of fibonacci series:
```js
function fib(n) {
    if (n<2) {
        return n;
    }
    return fib(n-1) + fib(n-2);
}

fib(30);
fib(30);
fib(30);
// computes all 3 lines hence takes some time for each line
```
it takes certain time for execution of same number.
To avoid recomputation you need to pull results from cache.

This is how you do it.
```js
let fibM = memoize(fib);

fibM(30);
fibM(30);
fibM(30);
// only computes first line and stores the result, fetches it for the next two lines
```
